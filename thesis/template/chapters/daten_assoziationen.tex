\chapter{Datenassoziationen}\label{chapter:association}

Wie in der Einleitung beschrieben, soll in einem ersten Ansatz analysiert werden, ob eine TSDF Karte mit gegebenem initialen Pfad durch die Optimierung des initialen Pfades mittels Schleifenschlüssen verbessert werden kann. Dazu ist im ersten Schritt zu identifizierten, welcher Teil der Karte mit welcher Pose assoziiert ist um bei einer Veränderung der Trajektorie entscheiden zu können, wie die Karte angepasst werden muss. Dies Kapitel befasst sich mit der Generation von Datenassoziationen zwischen den Posen des Pfades und der TSDF-Karte.

\section{Ansatz}
\label{section:ansatz}

Wie bereits in Kapitel \ref{section:tsdf} beschrieben, wird die TSDF Karte in \cite{HATSDF} inkrementell erweitert, sobald eine definierte minimale Distanz zurückgelegt wurde. Dabei werden nicht nur neue Zellen beschrieben, sondern auch die Werte bereits beschriebener Zellen gewichtet verändert. Dementsprechend kann die Information in einer Zelle eine Akkumulation beliebig vieler Updates sein und beliebig vielen Posen zugeordnet werden. Diese Information gilt es zu berücksichtigen, wenn auf Basis einer gegebenen TSDF Karte Datenassoziationen identifiziert werden sollen.
Eine Möglichkeit der Generation dieser Assoziation wäre eine \textbf{1:1} Beziehung zwischen den Zellen und Posen aufzubauen. Dann würde eine Zelle maximal einer Pose zugeordnet werden. Da bereits bekannt ist, dass eine Zelle von mehreren Posen angepasst werden kann, ist diese Art der Beziehung zwischen Posen und TSDF-Zellen allerdings von einem großen Informationsverlust geprägt. Die Alternative zur \textbf{1:1} Beziehung ist eine \textbf{1:N} Beziehung zwischen einer Zelle und $N$ Posen. Diese Beziehung ist aufgrund der genannten Eigenschaften des TSDF-Karten Updates der \textbf{1:1} Beziehung zu bevorzugen.

Die Informationen darüber, welche Position welche TSDF Zelle beschrieben lässt sich allerdings nicht ohne Weiteres aus der TSDF Karte herauslesen.
Um dies zu ermöglichen könnte \cite{HATSDF} um die Funktion erweitert werden an jeder Zelle zusätzlich ein Array zu speichern, in dem die Posen enthalten sind, die die betroffene Zelle modifiziert haben. Dieses Array muss in einem eigenen Datenset gespeichert sein, da die Anzahl Posen, die auf diese Weise einer Zelle zugeordnet werden können, dynamisch ist. Das bedeutet, dass für jede einzelne TSDF Zelle ein eigenes Datenset gespeichert werden muss, in dem die zugehörigen Posen enthalten sind. Je nach Auflösung der diskretisierten Karte müssten nach diesem Ansatz mehrere Millionen separate Datensets gespeichert werden. Ein solches Vorgehen erfordert nicht nur viel Speicher, sondern ist auch aus hierarchischer Betrachtungsweise keine sinnvolle Herangehensweise.
\improvement{TODO: anhand mehrerer Datensätze Assoziationen bilden und schauen, von wie vielen Posen eine Zelle im Durchschnitt angepasst wurde und hochrechnen, was das für den Speicher bedeutet}
Eine Möglichkeit, die gewünschten Daten auf Basis einer gegebenen TSDF Karte zu generieren ist diese über die Methode, mit der die Daten generiert wurden, zu regenerieren. In \cite{HATSDF} wird die TSDF-Karte über ein \textbf{Ray-Marching} generiert. Eine alternative zum Ray-Marching stellt der Bresenham Algorithmus dar, der die Diskretisierung der Karte ausnutzt.
Beide Varianten werden im Folgenden beschrieben, evaluiert und miteinander verglichen.
Zunächst beschreibt der folgende Abschnitt die Serialisierung der Datenassoziation in der HDF5-Datenstruktur.

\section{Serialisierung}


Diese Sektion beschreibt, wie identifizierte Assoziationen in der hierarchischen Struktur der HDF5-Datei gespeichert werden, die Daten der TSDF-Karte, sowie die zugehörige Pose-Historie enthält.
Wie in Kapitel \ref{section:tsdf} beschrieben, enthält die HDF5 Struktur mehrere Gruppen, die jeweils weitere Daten enthalten. Zu diesen Gruppen gehören in diesem Fall \textit{/map} und \textit{/poses}.
Die Map-Gruppe enthält die serialisierten TSDF-Zellenwerte und TSDF-Zellengewichte. Die Poses-Gruppe enthält die serialisierten 6D Posen des Pfades als Datensets.
Der HDF5 interne Pfad eines dieser Pose-Datensets ist \textit{/poses/[index]}, wobei \textit{index}, der Index der Pose im Pfad ist.
An dieser Stelle wird nun einer Erweiterung vorgenommen um die generierten Assoziationen zu serialisieren. Anstelle der Datensets wird für jede Pose eine eigene Gruppe erstellt. Diese Gruppe erhält als Namen ebenfalls den Pfadindex der Pose. Innerhalb dieser Gruppe wird ein Datenset für die Pose und optional ein weiteres Datenset für die Datenassoziationen angelegt, sofern erforderlich.
Abbildung \ref{fig:hdf5new} zeigt die neue interne HDF5 Struktur nach dieser Änderung.

\begin{figure}
		\centering
		\includegraphics
			[scale=0.4]
			{HDF5new}
		\caption
			[Caption for LOF]{Schematische Darstellung der HDF5 internen Datenstruktur nach Speicherung der generierten Datenassoziationen zwischen TSDF-Zellen und Posen. Die in Kapitel \ref{section:ansatz} beschrieben \textit{1:N} Beziehung zwischen einer Zelle und den zugehörigen Posen ist hier indirekt realisiert. Anstelle pro Zelle ein Datenset zu erstellen, wir für jede Pose ein Datenset enthält, das alle assoziierten TSDF-Zellen enthält. Verschiedene Posen können dabei dieselbe TSDF-Zelle assoziieren. Das Datenset \textit{pose} enthält die Transformation der aktuellen Pose ins Ursprungskoordinatensystem. Das Datenset \textit{associations} enthält ein Array der assoziierten Zellkoordinaten, die durch die Diskretisierung ganzzahlig sind und als Integer abgespeichert werden.}			                                                                                                                                     
		\label{fig:hdf5new}
\end{figure}

Auf Basis dieser Änderungen wird im Folgenden erläutert, wie die zu speichernden Zellen für jede Pose ermittelt werden.

\section{Algorithmen}

Diese Sektion stellt die Algorithmen heraus, mit denen beschriebene Assoziationen identifiziert werden können. Die Ergebnisse der Algorithmen werden miteiander verglichen und evaluiert.

\subsection{Ray-Tracing}
\label{section:ray-tracing}

Eine Möglichkeit der Ermittlung der mit einzelnen Posen assoziierten Teilbereiche der TSDF Karte ist die die Erstellung eines künstlichen Laserscans innerhalb der TSDF Karte, ausgehend von der entsprechenden Pose.
Entsprechend wurde im Zuge dieser Arbeit ein \textbf{Ray-Tracer} entwickelt, der künstliche Laserstrahlen innerhalb der TSDF-Karte aussendet und die Schnittpunkte mit der TSDF Karte überprüft. Der Ray-Tracer ist beliebig konfigurierbar ist und kann an die Parameter verschiedenster Laserscanner angepasst werden.
Die wesentlichen Parameter und deren Bedeutung sind Tabelle \ref{table:raytracer_params} zu entnehmen.
	
	\begin{table}
		\centering
		\caption{Parameter des in dieser Arbeit entwickelten Ray-Tracers zur Bestimmung des mit einer beliebigen Pose assoziierten Teilbereichs der TSDF-Karte. Der horizontale Öffnungswinkel wird an dieser Stelle als $360$ Grad angenommen.}
		\begin{tabular}{| p{3cm} | p{8cm} | p{2cm} |}
			\hline
			\thead{Parameter}   & \thead{Funktionsweise}  & \thead{Default-\\Wert}\\
			\hline
			$opening\_degree$   & Definiert den vertikalen Öffnungswinkel des Ray-Tracers. Anzugeben in Grad. & $45$ \\
			\hline
			$hor\_res$     & Definiert die horizontale Auflösung des Laserscanners. Der gegebene Wert  entspricht der Anzahl \textit{Rays} pro Scanebene. & $1024$\\
			\hline			
			$vert\_res$    & Definiert die vertikale Auflösung des Laserscanners. Der gegebene Wert entspricht der Anzahl an Scanebenen im Laserscan. & $128$\\
			\hline			
			$step\_size$      & Definiert, wie groß die Schrittweite beim Aussenden der einzelnen Rays ist. Der Wert ist in Metern anzugeben. Der Default-Wert ist direkt an die Zellgröße der diskreten TSDF-Karte $map_{res}$ gekoppelt und beträgt $\frac{map_{res}}{2}$. & $0.032$ \\
			\hline			
			$ray\_size$   & Definiert die Dicke des Strahls in der Visualisierung. Dieser Parameter dient lediglich zur erleichterten Visualisierung des Laserscans bei unterschiedlicher Konfiguration. Der Wert ist in Metern anzugeben. & $0.01$ \\
			\hline
		\end{tabular}
		\label{table:raytracer_params}
	\end{table}	
	
Zur Emulation das Laserscans wird zunächst ein Array erstellt, in dem die aktuellen Endpunkte der jeweiligen Rays gespeichert werden. Die Anzahl an Endpunkten $n$ ist definiert durch die konfigurierte Auflösung. Sie beträgt:

\begin{myequation}
n = vert\_res \cdot hor\_res
\end{myequation}

 Der Startpunkt jedes Rays ist die Pose $P_i$, von der aus der Laserscan ausgesendet wird. Ziel ist in jeder Iteration alle Rays um $step\_size$ zu verlängern und die TSDF-Zellen zu evaluieren, die derzeit von den einzelnen Rays getroffen werden. Für diese Verlängerung der Rays müssen diese zunächst initialisiert werden. Diese Initialisierung erfolgt auf Basis der parametrisierten Öffnungswinkel des Laserscanners $opening\_degree\_vert$ und $opening\_degree\_hor$, sowie der konfigurierten vertikalen und horizontalen Auflösung $vert\_res$ und $hor\_res$.
Zunächst werden die Winkelbereiche definiert, in den der Ray-Tracer operiert. Diese setzten sich aus den Öffnungswinkeln zusammen. Der Winkelbereich in horizontaler Richtung beträgt:

\begin{myequation}
I_{hor} = \left[-opening\_degree\_hor, opening\_degree\_hor \right]
\end{myequation}

Der Winkelbereich in vertikaler Richtung beträgt:

\begin{myequation}
I_{vert} = \left[-opening\_degree\_vert, opening\_degree\_vert \right]
\end{myequation}

Die jeweiligen Winkelbereiche werden durch die konfigurierte Auflösung diskretisiert.
Die horizontale Schrittweite des Laserscanners beträgt:

\begin{myequation}
\Delta_{hor} = \frac{opening\_degree\_hor}{hor\_res}
\end{myequation}

Die vertikale Schrittweite des Laserscanners beträgt:

\begin{myequation}
\Delta_{vert} = \frac{opening\_degree\_vert}{vert\_res}
\end{myequation}

Basierend auf den unteren und oberen Winkelschranken und der berechneten Schrittweite zwischen diesen Schranken kann nun das Array initialisiert werden. Dazu wird in zwei Schleifen über die beiden Winkelintervalle $I_{vert}$ und $I_{hor}$ iteriert und der aktuelle Wert jeweils um die berechneten Delta $\Delta_{vert}$ und  $\Delta_{hor}$ inkrementiert. Aus den beiden Winkeln $\alpha$ und $\beta$ der aktuellen Iteration der Schleifen, sowie einer beliebigen Distanz initialen Länge des Rays, wie zum Beispiel der Schrittweite $step\_size$ können nun für jeden Punkt die initialen Ray-Punkte berechnet werden, die den Richtungsvektor des Rays definieren.
Hierzu ist eine Umwandlung von Kugelkoordinaten in das Kartesische Koordinatensystem notwendig. Mit $alpha$, $beta$ und $step\_size$ wird in Kugelkoordinaten genau ein Punkt im dreidimensionalen Raum beschrieben. Um diese in kartesische Koordinaten im ROS Koordinatensystem umzuwandeln wird folgende Formel verwendet ($\alpha$ und $\beta$ gegeben in Radianten, $\alpha$ beschreibt den aktuellen Winkel um die z-Achse, $\beta$ die aktuelle Rotation um die y-Achse):

\begin{myequation}
\colvec{x_{P_i}\\y_{P_i}\\z_{P_i}} = step\_size \cdot \colvec{\cos\left(\alpha \right) \cdot \cos\left(\beta \right) \\ \sin\left(\alpha \right) \cdot \cos\left(\beta \right) \\ \sin\left(\beta \right)}
\end{myequation}

Der Punkt $\colvec{x_{P_i}\\y_{P_i}\\z_{P_i}}$ beschreibt hier zunächst nur den Ray-Punkt aus Sicht des lokalen Map-Koordinatensystems, das durch ${P_i}$ beschrieben ist. Um diesen aus Sicht des globalen Koordinatensystems $\mathbb{M}$ zu betrachten, muss dieser Punkt dorthin transformiert werden. Grundlagen zur Transformation werden in Kapitel \ref{section:transformationen} behandelt. Es ist essentiell, dass an dieser Stelle nicht nur die Translation, sondern auch die Rotation berücksichtigt wird um den Scan von Pose $P_i$ bestmöglich replizieren zu können. Die Transformation des Vektors $\colvec{x_{P_i}\\y_{P_i}\\z_{P_i}}$ vom Koordinatensystem beschrieben durch Pose $P_I$ in das globale Koordinatensystem $\mathbb{M}$ mit der Transformationsmatrix $T_{P_i \rightarrow \mathbb{M}}$ ist gegeben durch:

\begin{myequation}
\colvec{x_{\mathbb{M}}\\y_{\mathbb{M}}\\z_{\mathbb{M}}} = T_{P_i \rightarrow \mathbb{M}} \cdot \colvec{x_{P_i}\\y_{P_i}\\z_{P_i}}
\end{myequation}

Auf diese Weise werden alle initialen Endpunkte des emulierten Laserscans berechnet. Auf Basis der berechenten initialen Endpunkte und des bekannten Anfangspunktes gegeben durch den Translationsanteil von $P_i$ kann das inkrementelle Ray-Tracing beginnen.
In jeder Iteration des Ray-Tracing werden alle Rays um $step\_size$ verlängert und die entsprechend getroffenen Zellen evaluiert. Um einen Vektor $\vec{v}$ gegeben durch den Translationsanteil $\vec{t_i}$ und den aktuellen Endpunkt des betrachteten Rays $\vec{r_i}$ um $step\_size$ zu verlängern und daraus den neuen Endpunkt des Rays $\hat{\vec{r_{i}}}$ zu berechnen wird folgende Formel verwendet:

\begin{myequation}
\hat{\vec{r_{i}}} = \frac{\norm{\vec{r_i} - \vec{t_i}} + step\_size}{\norm{\vec{r_i} - \vec{t_i}}} \cdot \left( \vec{r_i} - \vec{t_i} \right) + \vec{t_i} 
\end{myequation}

Nach der Verlängerung eines Rays $\vec{r_i}$ wird die inder aktuellen Iteration $j$ getroffene TSDF-Zelle $C_i^j$ evaluiert. Je nach Schrittweite $step\_size$ und Auflösung des Ray-Tracers ist es möglich, dass $C_i^j$ bereits evaluiert wurde und schon eine Assoziation mit der Pose $P_i$ hergestellt ist. Um diesen Fall zu überprüfen und zu verhindern, dass duplizierte Assoziationen gespeichert werden, wird eine Hash-Map genutzt, deren Hash auf Basis der Koordinaten der TSDF-Zelle berechnet wird. Ist $C_i^j$ bereits in der Hash-Map gespeichert, ist der aktuell betrachtete Ray $\vec{r_i}$ für diese Iteration fertig evaluiert und der nächste Ray kann betrachtet werden. Um zu entscheiden ob eine nicht assoziierte Zelle $C_i^j$ als Assoziation in Frage kommt müssen mehrere Zustände des Rays definiert werden. Abbildung \ref{fig:RayTracingBig} zeigt die benötigten Zustände und die Bedinungen für einen Wechsel des Status gegeben den aktuellen Status und die betrachtete Zelle $C_i^j$, sowie dieren TSDF-Wert und TSDF-Gewicht. Ein Ray ist beschränkt durch die lokale Karte um $P_i$ \ref{section:tsdf_map}, sowie die Struktur der TSDF-Karte. Detektiert ein Ray einen einen Wechsel von positive auf negative TSDF-Werte (\textbf{Nulldurchgang}) in der TSDF, stoppt der Ray-Tracer, sobald er erneut positive Werte detektiert. Diese Herangehensweise sorgt dafür, dass mit der Pose $P_i$ keine Zellen assoziiert werden, die von dieser Pose aufgrund der Begrenzungen der lokalen Karte nicht gesehen werden konnten oder hinter Wänden befindlich sind.

\begin{figure}
		\centering
		\includegraphics
			[scale=0.3]
			{RayTracingBig}
		\caption
			[Caption for LOF]{Schematische Darstellung 2D Darstellung der verschiedenen Zustände eines einzelnen Rays des Ray-Tracers innerhalb einer TSDF-Darstellung. Negative TSDF-Werte dargestellt in rot, positive in grün. Der approximierte Nulldurchgang in der TSDF ist hier gräulich dargestellt, die umgebende lokale Karte in gelb. Ausgehend von Pose $P_i$ sind zwei Rays $r_{i1}$ und $r_{i2}$ dargestellt, die die verschiedenen Fälle abdecken, die es zu berücksichtigen gilt. Eine genaue Beschreibung der Zustandsänderungen der Rays im Zustandsdisgramm \ref{fig:Ray-Trace-Zustandsdiagramm} zu entnehmen. Die entsprechenden Zustände sind dargestellt als blaue Kreise, die die jeweilige Zustandsnummer enthalten. Die entsprechenden Definitionen der Zustände sind ebenfalls im Zustandsdiagramm \ref{fig:Ray-Trace-Zustandsdiagramm} zu entnehmen. Die mit einem Blitz markierten Zellen werden zwar von dem ausgesandten Ray $r_{i1}$ getroffen, dürfen allerdings aufgrund der Evidenz im aktuellen Ray nicht mit der Pose assoziiert werden, da im Anschluss an diese Zellen kein Nulldurchgang, sondern Freiraum folgt. Der Freiraum ist hier in weiß dargestellt und setzt sich aus den TSDF-Zellen zusammen, die Default-Werte enthalten und entsprechend außer der minimalen Entfernung $tau \left(\tau\right)$ zur Oberfläche, keine räumlichen Informationen besitzen. Gleicher Ausnahmefall tritt ein, wenn der Ray lediglich negative TSDF-Zellen trifft. Diese werden ebenfalls nicht aufgrund der Evidenz des betrachteten Rays mit der Pose assoziiert.}		                                                                                                                                     
		\label{fig:RayTracingBig}
\end{figure}

\begin{figure}
		\centering
		\includegraphics
			[scale=0.25]
			{Ray-Trace-Zustandsdiagramm}
		\caption
			[Caption for LOF]{Zustandsdiagramm der internen Zustände eines Rays. Zustandsübergänge sind beschrieben durch einen initialen Zustand und den TSDF-Wert der aktuellen Zelle (\textit{value}). In Zustand 1 werden gefundene Assoziationen zunächst nicht abgespeichert, da noch nicht bekannt ist, ob diese Zellen zu einem Nulldurchgang gehören oder ob der Ray nur Zellen kreuzt, die von einer anderen Pose aus befüllt wurden. Je nach TSDF-Wert der aktuellen Zelle werden die zwischengespeicherten Assoziationen aus Zustand 1 entweder verworfen oder in der HDF5 gespeichert.}		                                                                                                                                     
		\label{fig:Ray-Trace-Zustandsdiagramm}
\end{figure}

Die Ergebnisse dieses Ansatz sind in Abbildung \ref{fig:bresenham_vs_raytrace}im Vergleich mit den Ergebnisses des Bresenham Algorithmus dargestellt, der in der nachfolgenden Sektion behandelt wird. In dem genutzten Datensatz können nur etwa $91\%$ der Zellen assoziiert werden. Diese Zahl ähnelt auch der von Bresenham. \improvement{Für mehrere Datensätze zahlen bilden, graphlich darstellen}. Sektion \ref{section:association_evaluation} evaluiert die Ergebnisse von Ray-Tracing und Bresenham und vergleicht diese miteinander. Zudem wird Bezug zum Informationsverlust bei der Assoziationsidentifikation genommen.


\improvement{Beschreibung von Türen, Beschreibung von Problem wie Verdeckung durch Diskretisierung, ggf. Ray-Trace Bild, Beschreibung von Fallstricken: Nicht getroffene Zellen, Information loss}

\improvement{ggf. RVIZ-Bild des Ray-Tracing Markers}
\improvement{Tür-Problem}

\subsection{Bresenham}

Eine alternative algorithmische Herangehensweise an das beschriebene Problem der Assoziationsidentifikation ist die Nutzung des Bresenham-Algorithmus nach Bresenham \cite{bresenham1965algorithm}. Dieser wurde usprünglich verwendet, um einen digitalen Plotter mittels eines Computers zu kontrollieren und beliebige zweidimensionale Linien und Kurven approximativ abzubilden. Der Plotter lässt sich dabei in acht Richtungen auf einem diskretisierten Raster bewegen. Bresenham \cite{bresenham1965algorithm} beschreibt, wie sich die Zellen im Raster berechnen lässt, die das gegebene Liniensegment einer Kurve oder eine Linie am besten beschreibt. Der Bresenham Algorithmus findet heutzutage vielfach Anwendung im Bereich der Computergrafik. Hier liegt eine Diskretisierung durch die Auflösung des Computers in Pixeln vor. Mittels des Bresenham Algorithmus kann bestimmt werden, durch welche Pixel eine Linie oder ein Liniensegment beschrieben werden kann. Abbildung \ref{fig:Bresenham2D} zeigt die initiale Idee des Bresenham Algorithmus in zwei Dimensionen. Eine ähnliche Diskretisierung weist auch die in dieser Arbeit verwendete TSDF-Karte auf. Sie ist allerdings im Gegensatz zu den beschriebenen Beispielen in drei Dimensionen diskretisiert. Mittels Bresenham soll bestimmt werden, welche Voxel der TSDF-Karte zu einem Ray gehören, der von einer Position $\vec{p}$ ausgesendet wurde und sich mit der TSDF-Karte schneidet. Ziel ist die Beschleunigung des Ray-Tracing Ansatzes durch die Ausnutzung der Registrierung der Karte. Dabei gelten die gleichen Voraussetzungen wie beim zuvor beschriebenen Ray-Tracing und die Initialisierung der einzelnen Rays erfolgt analog. Im Gegensatz zum Ray-Tracing wird allerdings nicht der Ray schrittweise verlängert, sondern basierend auf den initialen Richtungsvektoren der Rays jeweils das nächste Voxel berechnet, das den Ray am besten beschreibt.

\begin{figure}
		\centering
		\includegraphics
			[scale=0.2]
			{Bresenham2D}
		\caption
			[Caption for LOF]{Schematische Darstellung des Bresenham-Algorithmus in zwei Dimensionen. Der Bresenham Algorithmus bestimmt, welche Voxel die Linie zwischen einem gegebenen Startvoxel und einem Endvoxel am besten beschreiben.}		                                                                                                                                     
		\label{fig:Bresenham2D}
\end{figure}

Die Grundlage für die Berechnung der zum Ray gehörigen Voxel bildet ein Startvoxel $\vec{V_{start}}$, gegeben durch die aktuell betrachtete Pose beziehungsweise Scannerposition $P_{i}$ und ein Endvoxel $\vec{V_{end}}$. Letzterer berechnet sich aus dem Schnittpunkt des betrachteten Rays mit der Bounding-Box der lokalen Karte, gekennzeichnet durch ihren Ursprung $\vec{p_{lmap}}$ und ihre Seitenlängen $\left(s_x, s_y, s_z\right)^T$.
\improvement{ggf. Mathematik dahinter erklären}. Basierend auf den berechneten Start- und Endvoxeln jedes Rays können nun die dazwischenliegenden Voxel mittels Bresenham ermittelt werden. Der Pseudo-Code in Abbildung \ref{pseudo:bresenham} legt die Logik für die Bestimmung der der Voxel dar, die die Linie gegeben durch den Startvoxel $\vec{V_{start}}$ und Endvoxel $\vec{V_{end}}$ beschrieben. 

\begin{algorithm}[H]
\caption{Bresenham Algorithmus adaptiert in 3D (nach \cite{bresenham1965algorithm})} \label{pseudo:bresenham}
\begin{algorithmic}[1]
\Procedure{Bresenham}{ $\vec{V_{start}}, map_{l}, r_i^j$}
	\State{\textbf{\textsl{Initialisierung:}}}
	\State Berechne die Endposition $\vec{V_{end}}$ als Schnittpunkt des Rays $r_i^j$ mit der lokalen Karte $map_{l}$
	\State Berechne Bresenham Parameter (absolute Abstände und Raumrichtungen):
	\State $dx = \abs{\vec{V_{end}}^x - \vec{V_{start}}^x}$ \Comment{Absolute zwischen den Punkten in alle Raumrichtungen}
	\State $dy = \abs{\vec{V_{end}}^y - \vec{V_{start}}^y}$
	\State $dz = \abs{\vec{V_{end}}^z - \vec{V_{start}}^z}$
	\State $dm = max(dx, dy, dz)$ \Comment Maximale Komponente der Manhattan Distanz
	\State $sx = \vec{V_{start}}^x < \vec{V_{end}}^x$ ? $1$ : $-1$ \Comment{Raumrichtung}
	\State $sy = \vec{V_{start}}^y < \vec{V_{end}}^y$ ? $1$ : $-1$
	\State $sz = \vec{V_{start}}^z < \vec{V_{end}}^z$ ? $1$ : $-1$
	\State \textbf{\textsl{Temporäre Vektoren zur Iteration initialisieren:}} 
	\State $\vec{v_0} = \left(x_0, y_0, z_0\right)^T = \vec{V_{start}}$ und $\vec{v_0} = \left(x_1, y_1, z_1\right)^T = \left(\frac{dm}{2}, \frac{dm}{2}, \frac{dm}{2}\right)^T$
	\For{$i = 1; i < dm; i++$} \Comment{$\left(dm - 1\right)$ mal iterieren}
		\State \textbf{\textsl{Berechnung des nächsten Voxels (gegeben durch $\vec{v_0}$)}}
		\State $x_1 = x_1 - d_x;$ \hskip \algorithmicindent if $\left(x_1 < 0 \right) \left\lbrace x_1 += d_m; \hskip \algorithmicindent x_0 += s_x; \right\rbrace$
		\State $y_1 = y_1 - d_y;$ \hskip \algorithmicindent if $\left(y_1 < 0 \right) \left\lbrace y_1 += d_m; \hskip \algorithmicindent y_0 += s_y; \right\rbrace$
		\State $z_1 = z_1 - d_z;$ \hskip \algorithmicindent if $\left(z_1 < 0 \right) \left\lbrace z_1 += d_m; \hskip \algorithmicindent z_0 += s_z; \right\rbrace$
		\State Neues Linien-Voxel gegeben durch: $\vec{v_0}$ bzw. $\left(x_0, y_0, z_0\right)^T $
	\EndFor \label{Rays-Loop}
\EndProcedure
\end{algorithmic}
\end{algorithm}

Mit Hilfe dieser Logik lässt sich iterativ für jeden Ray $r_i^j \in R_i$ der nächste zugehörige Voxel berechnen und evaluieren. Die Evaluation der von Bresenham ermittelten, aktuell vom Ray getroffenen TSDF-Zellen erfolgt analog zu der Evaluation des Ray-Tracing entsprechend des Zustandsdiagramms in Abbildung \ref{fig:Ray-Trace-Zustandsdiagramm}. Das Abbruchkriterium für jeden Ray $r_i^j$ beim Bresenham ist entweder das Erreichen des Zielzustands im Zustandsdiagramm oder das Erreichen des zu $r_i^j$ zugehörigen Endvoxels $\vec{V_{end}}$.
Ingesamt ergibt sich der in Abbildung \ref{pseudo:associations} dargestellte Pseudo-Code, bei variabler Verwendung von Bresenham oder Ray-Tracing. Dieser Pseudo Code wird zur Assoziationsbestimmung ausgehend von jeder Pose $P_i$ ausgeführt, für die die Assoziationen bestimmt werden sollen.


\begin{algorithm}[H]
\caption{Asssoziations-Berechnung mittels Bresenham oder Ray-Tracing} \label{pseudo:associations}
\begin{algorithmic}[1]
\Procedure{Assoziations-Berechnung}{ $P_i, map_{local}$ }
	\State{\textbf{\textsl{Initialization:}}}
	\State Initialisiere die Rays $R_i$ um $P_{i}$ wie beschrieben in \ref{section:ray-tracing}
	\State Initialisiere ein Array $r_{status}$ der Größe der Anzahl von Rays, welches die aktuellen 				Zustände der Rays, gegeben durch das Zustandsdiagramm in \ref{fig:Ray-Trace-Zustandsdiagramm} beschreibt
	\State Initialisiere einen Zähler für die Anzahl der fertigen Rays: $cnt_{fin} = 0$
	\While{$cnt_{fin} < size\left(r_{status}\right)$}
		\For{$r_i^j$ in $R_i$}
			\State Ermittle nächstes Voxel $V_i^j$ mittels Ray-Tracing oder Bresenham
			\State Evaluiere $V_i^j$ auf Basis des Zustandsdiagramms in \ref{fig:Ray-Trace-Zustandsdiagramm}
			\State Speichere $V_i^j$ als Assoziation, wenn es gemäß \ref{fig:Ray-Trace-Zustandsdiagramm} mit $P_i$ assoziiert ist
		\EndFor \label{Rays-Loop}
	\EndWhile
	\State Speichere die gefunden Assoziationen gemäß \ref{fig:hdf5new} in der HDF5
\EndProcedure
\end{algorithmic}
\end{algorithm}

In den folgenden beiden Sektionen werden die Ergebnisse der Assoziationsbestimmung evaluiert und es findet ein Vergleich zwischen den beiden vorgestellten Algorithmen statt.

\subsection{Ergebnisse}
\label{section:association_results}

Abbildung \ref{fig:bresenham_vs_raytrace} zeigt eine Gegenüberstellung der Ergebnisse der Evaluationsbestimmung zwischen Bresenham und dem Ray-Tracing Ansatz. Es ist ersichtlich, dass in beiden Figuren sehr ähnliche Ergebnisse erzielt werden konnten. Dies lässt sich auch an dem Prozentsatz der assoziierten Zellen von der Gesamtheit der Zellen kenntlich machen. Hier beträgt der Unterschied zwischen den beiden Ansätzen lediglich $0.23 \%$, die vom Ray-Tracer zusätzlich assoziiert wurden. Dieser Unterschied lässt sich anhand einiger Eigenschaften von Bresenham deutlich machen. Der Algorithmus erlaubt unter gewissen Umständen, das aufeinander folgende Zellen nur an der Ecke miteinander verbunden sind. Dann gilt zum Beispiel  $C_i = (0,0,0)^T$ und $C_{i+1} = (1,1,1)^T$. Dies ist eine der Ursachen die dazu führt, dass grundsätzlich nicht alle Zellen assoziiert werden können. Auch das Ray-Tracing weist ähnliche Probleme aufgrund der Diskretisierung der Schritte auf. Hier können durch die diskreten Schritte Zellen Zellen übersprungen werden, die in einer kontinuierlichen Betrachtungsweise vom Ray getroffen werden. Dieses Problem ist beim Ray-Tracer allerdings vernachlässigbar, solange die Schrittweite identisch zu derer gewählt wird, die beim Update der TSDF-Karte, in welchem nach Kapitel \ref{} ebenfalls ein Ray-Tracing Ansatz gewählt wurde, verwendet wird. Dadurch kann sichergestellt werden, dass Zellen, die beim Update der TSDF-Karte ausgehend von $P_i$ verändert wurden, auch von dem Ray-Tracer zur Datenassoziation getroffen werden. Dies erklärt dementsprechend nicht die restlichen knapp $9\%$ der Zellen, die durch den Ray-Tracer nicht assoziiert werden konnten. Der Prozentsatz variiert je nach verwendetem Datensatz und der Struktur der Daten. Nachfolgender Abschnitt erörtert das Problem der nicht assoziierten Zellen.


\begin{figure}
	\centering
	\begin{subfigure}{.5\textwidth}
 		 \centering
  		 \includegraphics[width=.95\linewidth]{sp_bresenham_91_74_}
  		 \centering \caption{Assoziationen identifiziert mit Bresenham.}
  		 \label{fig:sp_bresenham}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
    	\centering
  		\includegraphics[width=.95\linewidth]{sp_raytrace_91_97_}
  		\centering \caption{Assoziationen identifiziert mit Ray-Tracing.}
  		\label{fig:sp_raytrace}
	\end{subfigure}
	\caption{Gegenüberstellung der generierten Assoziationen für einen Beispieldatensatz. Die durch Bresenham gefunden Assoziationen sind auf der linken Seite, die durch Ray-Tracing auf der rechten dargestellt. In diesem Fall wurden von Bresenham $91,74$ Prozent der Zellen assoziiert, während vom Ray-Tracing $91,97$ Prozent der Zellen assoziiert wurden. Zellen in gelb: assoziierte TSDF Zellen mit $value < 0$, Zellen in pink: assoziierte TSDF Zellen mit $value > 0$, Zellen in türkis: approximierter Nulldurchgang (Wechsel von positivem zu negativem Wert), Rest: nicht assoziierte Zellen. Zellen die nicht assoziiert werden, sind in diesem Fall größtenteils Teil von Verdeckungen oder Reflektionen des Laserscans und können als Outlier identifiziert werden.}
	\label{fig:bresenham_vs_raytrace}
\end{figure}

\subsection{Evaluation}
\label{section:association_evaluation}

Diese Sektion befasst sich mit den Problematiken bei der Bestimmung von Assoziationen zwischen einer gegebenen Trajektorie und einer bestehenden TSDF-Karte. Zusätzlich erfolgt im zweiten Teil eine Evaluation der Laufzeiten zwischen dem Bresenham Algorithmus und dem Ray-Tracing. 

Im vorigen Abschnitt wurde beschrieben, dass ein je nach Datensatz variabler Prozentsatz der Karte nicht durch den Ray-Tracer und ebenfalls nicht durch Bresenham mit einer der Posen assoziiert werden kann. Dieses Problem wird sowohl durch die diskreten Schritte beim Ray-Tracer, als auch durch eine unpassende Wahl der nächsten Zelle im 3D Bresenham Algorithmus ausgelöst. Diese beiden Probleme sorgen allerdings nur zum Teil für die nicht assoziierten Zellen. Eine wesentliche Ursache sind durch die Diskretisierung eintretende Verdeckungen und Reflexionen beziehungsweise nicht gefiltertes Sensorrauschen bei der Generation der Karte, das für einzelne in der Luft schwebende TSDF-Zellen sorgt. Ein Beispiel für beschriebene Verdeckungen sind zum Beispiel Türen. In der Realität kann ein Laserscanner beliebig nah am Türrahmen vorbei scannen. Hier wird der Sichtbereich durch die Tür lediglich vom Türrahmen eingeschränkt. In einer diskretisierten TSDF-Karte wird der Sichtbereich durch die Tür je nach der Auflösung der Karte eingeschränkt. Abbildung \ref{} zeigt dieses Problem schematisch in "D anhand einer Pose und einem Hindernis, wie zum Beispiel einem Pfeiler. Es ist erkenntlich, dass ein Teil des ursprünglichen Sichtbereichs nun durch die diskretisierte TSDF-Karte verdeckt ist und alle Zellen, die sich im verdeckten Bereich hinter dem Hindernis nicht mehr assoziiert werden können. Dies ist die Hauptursache für beschriebene Probleme bei der Assoziationsbestimmung und kann ohne zusätzliche Informationen innerhalb der TSDF-Karte nicht gelöst werden. Eine Möglichkeit wäre, es dem Ray-Tracer zu erlauben, durch Wände hindurch zu sehen, was allerdings dazu führen könnte, dass Zellen mit der Pose assoziiert werden, die nicht zu ihr gehören. Dies ist einer der Hauptgründe für eine grundlegende Veränderung der Herangehensweise an das in dieser Arbeit formulierte Problem. \ref{section:ass_lc} eruiert weitere Probleme dieses ersten Ansatzes.

Abbildung \ref{fig:BresenhamVsRayTracing} zeigte eine Gegenüberstellung der Laufzeiten des Bresenham-Algorithmus in 3D gegenüber des vorgestellten Ray-Tracing Ansatzes. Es wird deutlich, dass durch die Einführung des Bresenham Algorithmus eine deutliche Steigerung der Effizienz erzielt wird.

\begin{figure}
		\centering
		\includegraphics
			[scale=0.7]
			{BresenhamVsRayTracing}
		\caption
			[Caption for LOF]{Laufzeiten der vorgestellten Algorithmen zur Bestimmung der Assoziationen. Es handelt sich bei den jeweiligen Werte um das Mittel der Laufzeiten mehrerer künstlicher Scans beider Algorithmen, ausgehend von ungefähr 30 verschiedenen Positionen. Es ist zu sehen, dass - obgleich der Zeitbedarf beider Algorithmen exponentiell mit der Anzahl an Rays steigt - der Bresenham Algorithmus wesentlich effizienter ist. Bei den Laufzeiten handelt es sich um nicht beschleunigte, rein CPU basierte Ansätze. Beide Varianten können durch die Nutzung einer \textbf{Graphics Processing Unit (GPU)} oder mittels CPU basierter Beschleunigung durch eine Parallelisierung deutlich beschleunigt werden. Diese Beschleunigung liegt jedoch nicht im Fokus dieser Arbeit. Dieses Benchmark bestätigt die Hypothese, dass die Laufzeit durch die Ausnutzung der Diskretisierung erheblich verbessert wird. wobei ähnliche Ergebnisse erzielt werden können.}		                                                                                                                                     
		\label{fig:BresenhamVsRayTracing}
\end{figure}


\section{Loop Closure}
\label{section:ass_lc}

Problem Loop Closure als Post-Processing Schritt ohne passende Punktwolke erklären:
einzige Repräsentation der Umgebung ist Karte
scan-matching erfordert Punktdaten, Möglichkeit: Approximation von punktwolken, funktioniert auch sehr gut (Beispielbild), aber: Punktwolken einer falsch generierten Karte aufeinander matchen ergibt nicht besonders viel sinn.

\section{Kartenupdate}

Beschreibung des Updates des ersten Ansatzes:
Beschreibung der drei Stufen und wie diese ermittelt wurden.
Beschreibung Hindernisse und Lösungen (Hashmaps)
Bezug zu Performanz der Hashmaps für diesen Fall (string, int, Vector3i)
-> kleines Benchmark

Beschreibung von Problemen:
Anschaulich erklären, wo es zu Problemen kommen kann (wenn benachbarte Zellen von unterschiedlichen Anzahl Posen "gesehen" wurden)

\subsection{Transformationen}



\improvement{Graph mit Prozenten Bresenham vs. Ray-Tracing bezüglich assoziierter Zellen, ggf. auch mit chemitz datenset}

Zum Test der ermittelten wurden auf den gegeben Pfad diverse Transformationen, wie das Verwischen \textbf{(Blur)} des Pfades, die Transformation oder Rotation des Pfades beziehungsweise eine Kombination mehrere Transformationen angewandt und auf Basis der Posedifferenzen ein Kartenupdate durchgeführt. Dies führte ebenfalls zu mehreren Problemen, insbesondere bei Rotationen.
Bilder für Translation, Blur, Rotation, Information loss (nicht getroffene Zellen) herausstellen, definieren wie dieser Information loss zustande kommt

\section{Evaluation}

Auf basis der vorigen sektionen erläutern, welche probleme es gibt, welche möglichen lösungsansätze es gibt und erklären, warum diese nicht weiter verfolgt wurden,
Überleitung in nächstes Kapitel (Loop Closures)
-> überlegen ob als nächstes kapiteö gegebenfalls das Kapitel über das map-update folgen sollte, damit die Überleitung sinnvoller ist




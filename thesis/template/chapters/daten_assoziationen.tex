\chapter{Datenassoziationen}\label{chapter:association}

Wie in der Einleitung beschrieben, soll in einem ersten Ansatz analysiert werden, ob eine TSDF Karte mit gegebenem initialen Pfad durch die Optimierung des initalen Pfades mittels Schleifenschlüssen verbessert werden kann. Die Grundlage für die Optimierung der Karte ist zu identifizieren, welcher Teil der Karte bei einer Veränderung der Trajektorie mit transformiert werden muss. Dies Kapitel befasst sich mit der Generation von Datenassoziationen zwischen den Posen des Pfades und der TSDF-Karte.

\section{Ansatz}
\label{section:ansatz}

Wie bereits in Kapitel \ref{section:tsdf} beschrieben, wird die TSDF Karte in \cite{HATSDF} inkrementell erweitert, sobald eine definierte minimale Distanz zurückgelegt wurde. Dabei werden nicht nur neue Zellen beschrieben, sondern auch die Werte bereits beschriebener Zellen gewichtet verändert. Dementsprechend kann die Information in einer Zelle eine Akkumulation beliebig vieler Updates sein, also beliebig vielen Posen zugeordnet werden. Diese Information gilt es zu berücksichtigen, wenn auf Basis einer gegebenen TSDF Karte Datenassoziationen identifiziert werden sollen.
Eine Möglichkeit der Generation dieser Assoziation wäre eine \textbf{1:1} Beziehung zwischen den Zellen und Posen aufzubauen. Dann würde eine Zelle maximal einer Pose zugeordnet werden. Da bereits bekannt ist, dass eine Zelle von mehreren Posen angepasst werden kann, ist diese Art der Beziehung zwischen Posen und TSDF-Zellen allerdings von einem großen Informationsverlust geprägt. Die Alternative zur \textbf{1:1} Beziehung ist eine \textbf{1:N} Beziehung zwischen einer Zelle und $N$ Posen. Diese Beziehung ist aufgrund der genannten Eigenschaften des TSDF-Karten Updates der \textbf{1:1} Beziehung zu bevorzugen.

Die Informationen darüber, welche Position welche TSDF Zelle beschrieben lässt sich allerdings nicht ohne Weiteres aus der TSDF Karte herauslesen.
Um dies zu ermöglichen könnte \cite{HATSDF} um die Funktion erweitert werden an jeder Zelle zusätzlich ein Array zu speichern, in dem die Posen enthalten sind, die die betroffene Zelle modifiziert haben. Dieses Array muss in einem eigenen Datenset gespeichert sein, da die Anzahl Posen, die auf diese Weise einer Zelle zugeordnet werden können, dynamisch ist. Das bedeutet, dass für jede einzelne TSDF Zelle ein eigenes Datenset gespeichert werden muss, in dem die zugehörigen Posen enthalten sind. Je nach Auflösung der diskretisierten Karte müssten nach diesem Ansatz mehrere Millionen separate Datensets gespeichert werden. Ein solches Vorgehen erfordert nicht nur viel Speicher, sondern ist auch aus hierarchischer Betrachtungsweise keine sinnvolle Herangehensweise.
\improvement{TODO: anhand mehrerer Datensätze Assozationen bilden und schauen, von wie vielen Posen eine Zelle im Durchschnitt angepasst wurde und hochrechnen, was das für den Speicher bedeutet}
%Eine andere Möglichkeit wäre \cite{HATSDF} so zu erweitern, dass für jede Pose $P_t$ die Koordinaten der TSDF Zellen gespeichert werden, die im Zeitschritt beziehunsweise Inkrement $t$ angepasst wurden.
Eine Möglichkeit, die gewünschten Daten auf Basis einer gegebenen TSDF Karte zu generieren ist diese über die Methode, mit der die Daten generiert wurden, zu regenerieren. In \cite{HATSDF} wird die TSDF-Karte über ein \textbf{Ray-Marching} generiert. Eine alternative zum Ray-Marching stellt der Bresenham Algorithmus dar, der die Diskretisierung der Karte ausnutzt.
Beide Varianten werden im Folgenden beschrieben, evaluiert und miteinander verglichen.

Zunächst beschreibt die folgende Sektion die Speicherung der Datenassoziation in der HDF5-Datenstruktur.

\section{Serialisierung}

Diese Sektion beschreibt, wie identifizierte Assoziationen in der HDF5-Datei gespeichert werden, die Daten der Karte enthält.
Wie bereits zuvor beschrieben, enthält die HDF5 Struktur mehrere Gruppen, die jeweils weitere Daten enthalten. Zu diesen Gruppen gehören in diesem Fall \textit{/map} und \textit{/poses}.
Die Map-Gruppe enthält dabei die serialisierten TSDF-Zellenwerte und TSDF-Zellengewichte. Die Poses-Gruppe enthält die serialisierten 6D Posen des Pfades als Datensets.
Der HDF5 interne Pfad eines dieser Pose-Datensets ist \textit{/poses/[index]}, wobei \textit{index}, der Index der Pose im Pfad ist.
An dieser Stelle wird nun einer Erweiterung vorgenommen um die generierten Assoziationen zu serialisieren. Anstelle der Datensets wird für jede Pose eine eigene Gruppe erstellt. Diese Gruppe erhält als Namen ebenfalls den Pfadindex der Pose. Innerhalb dieser Gruppe wird ein Datenset für die Pose und optional ein weiteres Datenset für die Datenassoziationen angelegt, sofern erforderlich.
Abbildung \ref{fig:hdf5new} zeigt die neue interne HDF5 Struktur nach dieser Änderung.

\begin{figure}[H]
		\centering
		\includegraphics
			[scale=0.4]
			{HDF5new}
		\caption
			[Caption for LOF]{Schematische Darstellung der HDF5 internen Datenstruktur nach Speicherung der generierten Datenassoziationen zwischen TSDF-Zellen und Posen. Die in Kapitel \ref{section:ansatz} beschrieben \textit{1:N} Beziehung zwischen einer Zelle und den zugehörigen Posen ist hier indirekt realisiert. Anstelle pro Zelle ein Datenset zu erstellen, wir für jede Pose ein Datenset enthält, das alle assoziierten TSDF-Zellen enthält. Verschiedene Posen können dabei dieselbe TSDF-Zelle assoziieren. Das Datenset \textit{pose} enthält die Transformation der aktuellen Pose ins Urpsrungskoordinatensystem. Das Datenset \textit{associations} enthält ein Array der assoziierten Zellkoordinaten, die durch die Diskretisierung ganzzahlig sind und als Integer abgespeichert werden.}			                                                                                                                                     
		\label{fig:hdf5new}
\end{figure}

Auf Basis dieser Änderungen wird im Folgenden erläutert, wie die zu speichernden Zellen für jede Pose ermittelt werden.

\section{RayTracing}

Eine Möglichkeit der Ermittlung der mit einzelnen Posen assoziierten Teilbereiche der TSDF Karte ist die die Erstellung eines künstlichen Laserscans innerhalb der TSDF Karte, ausgehend von der entsprechenden Pose.
Entsprechend wurde im Zuge dieser Arbeit ein \textbf{Ray-Tracer} entwickelt, der künstliche Laserstrahlen innerhalb der TSDF-Karte aussendet und die Schnittpunkte mit der TSDF Karte überprüft. Der Ray-Tracer ist beliebig konfigurierbar ist und kann an die Parameter verschiedenster Laserscanner angepasst werden.
Die wesentlichen Parameter und deren Bedeutung sind Tabelle \ref{table:} zu entnehmen.
	
	\begin{table}[H]
		\centering
		\caption{Parameter des in dieser Arbeit entwickelten Ray-Tracers zur Bestimmung des mit einer beliebigen Pose assoziierten Teilbereichs der TSDF-Karte. Der horizontale Öffnungswinkel wird an dieser Stelle als $360°$ angenommen}
		\begin{tabular}{| p{3cm} | p{8cm} | p{2cm} |}
			\hline
			\thead{Parameter}   & \thead{Funktionsweise}  & \thead{Default-\\Wert}\\
			\hline
			$opening\_degree$   & Definiert den vertikalen Öffnungswinkel des Ray-Tracers. Anzugeben in Grad. & $45°$ \\
			\hline
			$hor\_res$     & Definiert die horizontale Auflösung des Laserscanners. Der gegebene Wert  entspricht der Anzahl \textit{Rays} pro Scanebene. & $1024$\\
			\hline			
			$vert\_res$    & Definiert die vertikale Auflösung des Laserscanners. Der gegebene Wert entspricht der Anzahl an Scanebenen im Laserscan. & $128$\\
			\hline			
			$step\_size$      & Definiert, wie groß die Schrittweite beim Aussenden der einzelnen Rays ist. Der Wert ist in Metern anzugeben. Der Default-Wert ist direkt an die Zellgröße der diskreten TSDF-Karte $map_{res}$ gekoppelt und beträgt $\frac{map_{res}}{2}$. & $0,032$ \\
			\hline			
			$ray\_size$   & Definiert die Dicke des Strahls in der Visualisierung. Dieser Parameter dient lediglich zur erleichterten Visualisierung des Laserscans bei unterschiedlicher Konfiguration. Der Wert ist in Metern anzugeben. & $0,01$ \\
			\hline
		\end{tabular}
	\end{table}	
	
Zur Emulation das Laserscans wird zunächst ein Array erstellt, in dem die aktuellen Endpunkte der jeweiligen Rays gespeichert werden. Die Anzahl an Endpunkten $n$ ist definiert durch die konfigurierte Auflösung. Sie beträgt:

\begin{myequation}
n = vert\_res \cdot hor\_res
\end{myequation}

 Der Startpunkt jedes Rays ist die Pose $P_i$, von der aus der Laserscan ausgesendet wird. Ziel ist in jeder Iteration alle Rays um $step\_size$ zu verlängern und die TSDF-Zellen zu evaluieren, die derzeit von den einzelnen Rays getroffen werden. Für diese Verlängerung der Rays müssen diese zunächst initialisiert werden. Diese Initialisierung erfolgt auf Basis der parametrisierten Öffnungswinkel des Laserscanners $opening\_degree\_hor$ und $opening\_degree\_hor$, sowie der konfigurierten vertikalen und horizontalen Auflösung $vert\_res$ und $hor\_res$. 


Laserscanner emulieren: von den entsprechenden Posen aus werden künstliche Laserscans emuliert, die in Auflösung, Öffnungswinkeln mit dem verwendeten Laserscanner übereinstimmen
Implementation, die in der Lage ist, zu bestimmen wann eine TSDF Zelle getroffen wurde und wann eine Datenassozation erstellt wird.
Beschreibung von RayTrace States und Bedinungen für einen Wechsel der States, Beschreibung von Türen, Beschreibung von Problem wie Verdeckung durch Diskretisierung

Beschreibung von Fallstricken: Nicht getroffene Zellen, Information loss

\section{Bresenham}

alternative Möglichkeit zur Identifikation von Assoziationen
gut nutzbar, da eine diskrete Karte vorliegt
Beschleunigung gegenüber RayTracing in reiner Software Variante erklären
Algorithmus erklären
Varianten der Bestimmung von start/endzelle bestimmen: Schnittpunkt zwischen Ray und lokaler Karte, über vektor und abfrage


\section{Loop Closure}

Problem Loop Closure als Post-Processing Schritt ohne passende Punktwolke erklären:
einzige Repräsentation der Umgebung ist Karte
scan-matching erfordert Punktdaten, Möglichkeit: Approximation von punktwolken, funktioniert auch sehr gut (Beispielbild), aber: Punktwolken einer falsch generierten Karte aufeinander matchen ergibt nicht besonders viel sinn.

\section{Kartenupdate}

Beschreibung des Updates des ersten Ansatzes:
Beschreibung der drei Stufen und wie diese ermittelt wurden.
Beschreibung Hindernisse und Lösungen (Hashmaps)
Bezug zu Performanz der Hashmaps für diesen Fall (string, int, Vector3i)
-> kleines Benchmark

Beschreibung von Problemen:
Anschaulich erklären, wo es zu Problemen kommen kann (wenn benachbarte Zellen von unterschiedlichen Anzahl Posen "gesehen" wurden)

\section{Transformationen}

Zum Test der ermittelten wurden auf den gegeben Pfad diverse Transformationen, wie das Verwischen \textbf{(Blur)} des Pfades, die Transformation oder Rotation des Pfades beziehungsweise eine Kombination mehrere Transformationen angewandt und auf Basis der Posedifferenzen ein Kartenupdate durchgeführt. Dies führte ebenfalls zu mehreren Problemen, insbesondere bei Rotationen.
Bilder für Translation, Blur, Rotation, Information loss (nicht getroffene Zellen) herausstellen, definieren wie dieser Information loss zustande kommt

\section{Evaluation}

Auf basis der vorigen sektionen erläutern, welche probleme es gibt, welche möglichen lösungsansätze es gibt und erklären, warum diese nicht weiter verfolgt wurden,
Überleitung in nächstes Kapitel (Loop Closures)
-> überlegen ob als nächstes kapiteö gegebenfalls das Kapitel über das map-update folgen sollte, damit die Überleitung sinnvoller ist



